--- a/server_fn/src/middleware/mod.rs
+++ b/server_fn/src/middleware/mod.rs
@@ -17,7 +17,15 @@ impl<Req, Res> BoxedService<Req, Res> {
     }
 }
 
+#[cfg(feature = "axum-no-default")]
+impl<Req, Res> Clone for BoxedService<Req, Res> {
+    fn clone(&self) -> Self {
+        Self(self.0.clone_box())
+    }
+}
+
 /// A service converts an HTTP request into a response.
+#[cfg(not(feature = "axum-no-default"))]
 pub trait Service<Request, Response> {
     /// Converts a request into a response.
     fn run(
@@ -26,6 +34,33 @@ pub trait Service<Request, Response> {
     ) -> Pin<Box<dyn Future<Output = Response> + Send>>;
 }
 
+/// A service converts an HTTP request into a response.
+#[cfg(feature = "axum-no-default")]
+pub trait Service<Request, Response>: CloneService<Request, Response> {
+    /// Converts a request into a response.
+    fn run(
+        &mut self,
+        req: Request,
+    ) -> Pin<Box<dyn Future<Output = Response> + Send>>;
+}
+
+/// Make the service clonable
+#[cfg(feature = "axum-no-default")]
+pub trait CloneService<Req, Res> {
+    /// Clone the boxed service
+    fn clone_box(&self) -> Box<dyn Service<Req, Res> + Send>;
+}
+
+#[cfg(feature = "axum-no-default")]
+impl<Req, Res, S: ?Sized> CloneService<Req, Res> for S
+where
+    S: Service<Req, Res> + Clone + Send + 'static,
+{
+    fn clone_box(&self) -> Box<dyn Service<Req, Res> + Send> {
+        Box::new(self.clone())
+    }
+}
+
 #[cfg(feature = "axum-no-default")]
 mod axum {
     use super::{BoxedService, Service};
@@ -40,7 +75,10 @@ mod axum {
 
     impl<S> super::Service<Request<Body>, Response<Body>> for S
     where
-        S: tower::Service<Request<Body>, Response = Response<Body>>,
+        S: tower::Service<Request<Body>, Response = Response<Body>>
+            + Clone
+            + Send
+            + 'static,
         S::Future: Send + 'static,
         S::Error: Into<ServerFnError> + Send + Debug + Display + Sync + 'static,
     {
@@ -80,7 +118,10 @@ mod axum {
         }
 
         fn call(&mut self, req: Request<Body>) -> Self::Future {
-            let inner = self.0.run(req);
+            let (parts1, body) = req.into_parts();
+            let parts = parts1.clone();
+            leptos_reactive::provide_context(parts);
+            let inner = self.0.run(Request::from_parts(parts1, body));
             Box::pin(async move { Ok(inner.await) })
         }
     }
--- a/server_fn/Cargo.toml
+++ b/server_fn/Cargo.toml
@@ -10,6 +10,7 @@ readme = "../README.md"
 rust-version.workspace = true
 
 [dependencies]
+leptos_reactive = { workspace = true, optional = true }
 server_fn_macro_default = { workspace = true }
 # used for hashing paths in #[server] macro
 const_format = "0.2"
@@ -84,6 +85,7 @@ axum-no-default = [
   "dep:http-body-util",
   "dep:tower",
   "dep:tower-layer",
+  "dep:leptos_reactive"
 ]
 form-redirects = []
 actix = ["ssr", "dep:actix-web", "dep:send_wrapper"]
--- a/integrations/axum/src/lib.rs
+++ b/integrations/axum/src/lib.rs
@@ -282,7 +282,6 @@ async fn handle_server_fns_inner(
         let _guard = current_span.enter();
 
         let path = req.uri().path().to_string();
-        let (req, parts) = generate_request_and_parts(req);
 
         let res = if let Some(mut service) =
             server_fn::axum::get_server_fn_service(&path)
@@ -290,7 +289,6 @@ async fn handle_server_fns_inner(
             let runtime = create_runtime();
 
             additional_context();
-            provide_context(parts);
             provide_context(ResponseOptions::default());
 
             // store Accepts and Referer in case we need them for redirect (below)
